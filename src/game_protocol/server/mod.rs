use std::net::{Shutdown, TcpListener, TcpStream};
use std::ops::DerefMut;
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::io::{Read, Write};
use std::thread;
use uuid::Uuid;
use crate::common_message_utils::parse_message_data;
use crate::enums::{MessageType, StatusCode};
use crate::game_module::{GameModule, GameMove};
use crate::server::server_message_utils::{build_connect_response, build_game_state_response, build_lobby_info_response, build_lobby_list_response, build_missing_message_response, build_server_error_response, build_server_headers, build_supported_game_response, parse_client_message_header, parse_connect_request};
use crate::shared_data::{CreateLobbyRequest, JoinLobbyRequest, Lobby, StartGameRequest};

mod server_message_utils;

/*
    Server component of the game protocol.
    Handles accepting and storing clients, creating and storing lobbies an game sessions.
    Handle client messages, process data on the server appropriate to the request, and send a response
    appropriate to the request or the result of the processing.
 */

// Give TcpStream its own send_message function as a wrapper around the socket's write function.
pub trait SocketSend {
    fn send_message(&self, data: Vec<u8>);
}

impl SocketSend for TcpStream {
    fn send_message(&self, data: Vec<u8>) {
        match self.clone().write(data.as_slice()) {
            Ok(_) => {}
            Err(e) => {
                println!("Client socket write error. {:?}", e);
            }
        };
    }
}

// Simple struct for data specific to each client.
pub struct Client {
    socket: Arc<TcpStream>, // Socket on which client has connected to the server
    id: String, // Unique ID generated by the server to identify the client
    lobby_id: Option<String>, // If client is in a lobby, store the lobby ID
    next_message_id: u32 // The next message ID the server expects from the client
}

struct GameProtocolServerState {
    clients: HashMap<String, Client>, // Hash map of clients, indexed by client UUID
    lobbies: HashMap<String, Lobby>, // Hash map of lobbies, indexed by lobby UUID
    supported_games: HashMap<String, Arc<dyn GameModule>>, // Hash map of supported game factory objects, indexed by game module ID
    games_in_progress: HashMap<String, Box<dyn GameModule>> // Hash map of game sessions, indexed by lobby UUID
}

pub struct GameProtocolServer {
    state: Arc<Mutex<GameProtocolServerState>>, // Store server state in a thread safe pointer and mutex since it will be accessed across threads handling individual clients
    listener: Option<TcpListener>, // Listener object on which server listens for new incoming connections
    ip: String, // IP address on which the server runs
    port: String // Port number on which the server runs
}

impl GameProtocolServer {
    pub fn new(ip: &str, port: &str) -> Self {
        Self {
            state: Arc::new(Mutex::new(GameProtocolServerState{
                clients: HashMap::new(),
                lobbies: HashMap::new(),
                supported_games: HashMap::new(),
                games_in_progress: HashMap::new()
            })),
            listener: None,
            ip: ip.to_string(),
            port: port.to_string()
        }
    }

    // Register a game module by using generics. Generic must have a static lifetime and implement the GameModule trait.
    // That way we know that the game module will be compatible with protocol operations.
    pub fn register_game<T: 'static + GameModule>(&self) {
        let game = Arc::new(T::new());
        let mut state_lock = self.state.lock().unwrap();
        state_lock.supported_games.insert(game.get_metadata().get_game_type_id(),  game);
    }

    // Spin up the server and have it listen for incoming connection requests
    pub fn start(&mut self) {
        println!("Starting server...");
        // Binds a TCP listener to an IP address and port number, creating a socket address.
        match TcpListener::bind(format!("{}:{}", self.ip, self.port)) {
            Ok(listener) => {
                self.listener = Some(listener);
                println!("Server listening on port {}", self.port);
                self.start_server_loop();
            },
            Err(e) => {
                println!("TCP bind error: {}", e);
            }
        }
    }

    // Listen for any incoming client connections. For each one, split off into a new thread.
    // The main thread will listen for incoming client connections.
    fn start_server_loop(&mut self) {
        // Wait for incoming connection attempts.
        for stream in self.listener.as_ref().unwrap().incoming() {
            // Make sure getting the stream is successful.
            match stream {
                Ok(stream) => {
                    println!("New connection: {}", stream.peer_addr().unwrap());
                    self.listen_to_client(stream);
                },
                Err(e) => {
                    println!("Incoming stream error: {}", e);
                }
            }
        }
    }

    // Create a thread to continuously listen for requests coming from a client's socket.
    fn listen_to_client(&self, stream: TcpStream) {

        // Clone server state pointer to use in the newly spawned thread.
        let state_clone = self.state.clone();
        let client_socket = Arc::new(stream); // Wrap client socket in a thread safe pointer
        thread::spawn(move|| {
            // Initialize client ID as an empty string, indicating that it does not have an active session yet.
            let mut client_id = "".to_string();
            loop {
                let mut buffer = [0; 4096];

                // Read stream data into the buffer.
                match client_socket.as_ref().read(&mut buffer) {
                    Ok(size) => {
                        // If size of data is more than 0, then this is a message we are receiving.
                        // If size is 0, then socket is closed, so formally shut it down.
                        if size > 0 {
                            println!("Message received. Processing...");
                            let (message_id, message_type, remainder) = parse_client_message_header(&buffer);
                            println!("id: {}, type: {:?}, data size: {}", message_id, message_type, size);

                            // Set up variables pretty much each handler will need
                            let mut state_lock = state_clone.lock().unwrap();
                            let state_ref = state_lock.deref_mut();

                            // If client is not authenticated by the server and stored as a connected client,
                            // then server will only accept ConnectRequests and send client an error otherwise.
                            let is_id_empty = client_id.is_empty();
                            if is_id_empty && matches!(message_type, MessageType::ConnectRequest) {
                                // If authentication is successful, add client to the server_bin.
                                let connect_message = parse_connect_request(remainder);
                                if connect_message.authenticate() {
                                    // Create a new UUID for this client. Check for collisions.
                                    let mut new_client_id = Uuid::new_v4().to_string();
                                    let mut unique = false;
                                    while !unique {
                                        if state_ref.clients.contains_key(&new_client_id) {
                                            new_client_id = Uuid::new_v4().to_string();
                                        } else {
                                            unique = true;
                                        }
                                    }
                                    client_id = new_client_id.clone();

                                    // Create new client struct and add it to the hash map
                                    let new_client = Client {
                                        socket: client_socket.clone(),
                                        id: new_client_id.clone(),
                                        lobby_id: None,
                                        next_message_id: message_id + 1
                                    };
                                    state_ref.clients.insert(new_client_id.clone(), new_client);
                                    client_socket.send_message(build_connect_response(StatusCode::Success, new_client_id));
                                    continue;
                                }
                            } else if is_id_empty {
                                // Send client an error if it does not have an ID, indicating that it has not been added to the server_bin as an active client.
                                client_socket.send_message(build_server_headers(StatusCode::NoActiveSession, MessageType::ConnectResponse));
                                continue;
                            }

                            // Check message ID and compare it to the client's next expected ID.
                            if !is_id_empty {
                                let expected_id = state_ref.clients.get(&client_id).unwrap().next_message_id;
                                // If the incoming message ID does not match the expected ID, then gather a list of missing IDs.
                                if message_id != expected_id {
                                    let mut missing = vec![];

                                    if message_id > expected_id {
                                        // Received message ID is farther ahead than what is expected. Request the messages between
                                        let diff = message_id - expected_id;
                                        for id in expected_id..=expected_id + diff {
                                            missing.push(id);
                                        }
                                    } else {
                                        // Received message ID is less than what is expected. Need to get IDs that wrap around u32::MAX
                                        for id in expected_id..=u32::MAX {
                                            missing.push(id)
                                        }

                                        for id in 0..=message_id {
                                            missing.push(id);
                                        }
                                    };
                                    // Send missing message response and continue back to the beginning of the loop, waiting for the missing messages to be received.
                                    client_socket.send_message(build_missing_message_response(missing));
                                    continue;
                                }
                            }

                            // If the client ID is not an empty string, indicating it has an active session, then we handle any type of message from the client.
                            match message_type {
                                MessageType::DisconnectRequest => {
                                    // Break out of the listening loop and handle clean up at the bottom of this function.
                                    let response = build_server_headers(StatusCode::Success, MessageType::DisconnectResponse);
                                    client_socket.send_message(response);
                                    break;
                                }
                                MessageType::LobbyListRequest => {
                                    // Simply collect the lobbies stored in the hash map and put it in a vector
                                    let lobbies = state_ref.lobbies.clone().into_values().collect();
                                    let response = build_lobby_list_response(StatusCode::Success, &lobbies);
                                    client_socket.send_message(response);
                                }
                                MessageType::CreateLobbyRequest => {
                                    match parse_message_data::<CreateLobbyRequest>(remainder) {
                                        Ok(req) => {
                                            // Check if server supports the game. Otherwise send an error.
                                            if state_ref.supported_games.contains_key(&req.game_type_id) {
                                                let client = state_ref.clients.get_mut(&client_id).unwrap();

                                                if client.lobby_id.is_none() {
                                                    // Create a new UUID for this lobby. Check for collisions.
                                                    let mut new_lobby_id = Uuid::new_v4().to_string();
                                                    let mut unique = false;
                                                    while !unique {
                                                        if state_ref.lobbies.contains_key(&new_lobby_id) {
                                                            new_lobby_id = Uuid::new_v4().to_string();
                                                        } else {
                                                            unique = true;
                                                        }
                                                    }

                                                    // Create new lobby object
                                                    let new_lobby = Lobby {
                                                        owner: client.id.clone(),
                                                        id: new_lobby_id.clone(),
                                                        player_ids: vec![client.id.clone()],
                                                        game_started: false,
                                                        game_metadata: state_ref.supported_games.get(&req.game_type_id).unwrap().get_metadata().clone()
                                                    };

                                                    // Set client's lobby to the newly created one, add lobby to server, send lobby info to client
                                                    client.lobby_id = Some(new_lobby_id.clone());
                                                    state_ref.lobbies.insert(new_lobby_id, new_lobby.clone());
                                                    client_socket.send_message(build_lobby_info_response(StatusCode::Success, new_lobby.clone()));
                                                } else {
                                                    client_socket.send_message(build_server_headers(StatusCode::AlreadyInALobby, MessageType::ProtocolError));
                                                }
                                            } else {
                                                client_socket.send_message(build_server_headers(StatusCode::UnsupportedGame, MessageType::ProtocolError));
                                            }
                                        }
                                        Err(e) => {
                                            client_socket.send_message(build_server_error_response(e));
                                        }
                                    }
                                }
                                MessageType::SupportedGamesRequest => {
                                    // Simply collect supported game IDs and send it to client.
                                    let games = state_ref.supported_games.keys().cloned().collect();
                                    let response = build_supported_game_response(StatusCode::Success, &games);
                                    client_socket.send_message(response);
                                }
                                MessageType::JoinLobbyRequest => {
                                    match parse_message_data::<JoinLobbyRequest>(remainder) {
                                        Ok(req) => {
                                            let client = state_ref.clients.get_mut(&client_id).unwrap();

                                            // Make sure client isn't already in a lobby
                                            if client.lobby_id.is_none() {
                                                if state_ref.lobbies.contains_key(&req.lobby_id) {
                                                    let lobby = state_ref.lobbies.get_mut(&req.lobby_id).unwrap();

                                                    // If lobby isn't full, add the client to the lobby, send other connected clients updated lobby info, and send client lobby info
                                                    if !lobby.is_full() {
                                                        // Update lobby and client
                                                        lobby.player_ids.push(client_id.clone());
                                                        client.lobby_id = Some(req.lobby_id.clone());

                                                        // Build response to send to all clients in lobby, including the newly added one.
                                                        let response = build_lobby_info_response(StatusCode::Success, lobby.clone());
                                                        for client_id in lobby.player_ids.iter() {
                                                            state_ref.clients.get(client_id).unwrap().socket.send_message(response.clone());
                                                        }
                                                    } else if lobby.game_started {
                                                        client_socket.send_message(build_server_headers(StatusCode::GameStarted, MessageType::ProtocolError));
                                                    } else {
                                                        client_socket.send_message(build_server_headers(StatusCode::LobbyFull, MessageType::ProtocolError));
                                                    }
                                                } else {
                                                    client_socket.send_message(build_server_headers(StatusCode::LobbyNotFound, MessageType::ProtocolError));
                                                }
                                            } else {
                                                client_socket.send_message(build_server_headers(StatusCode::AlreadyInALobby, MessageType::ProtocolError));
                                            }
                                        }
                                        Err(e) => {
                                            client_socket.send_message(build_server_error_response(e));
                                        }
                                    }
                                }
                                MessageType::LobbyInfoRequest => {
                                    // Make sure client is in a lobby first. If so, send them the current info.
                                    let client = state_ref.clients.get(&client_id).unwrap();
                                    if let Some(lobby_id) = client.lobby_id.clone() {
                                        let lobby = state_ref.lobbies.get(&lobby_id).unwrap();
                                        client_socket.send_message(build_lobby_info_response(StatusCode::Success, lobby.clone()));
                                    } else {
                                        // If not in a lobby, send a lobby error with NotInLobby
                                        client_socket.send_message(build_server_headers(StatusCode::NotInLobby, MessageType::ProtocolError));
                                    }
                                }
                                MessageType::LeaveLobbyRequest => {
                                    // If the client is in a lobby, then leave it.
                                    let client = state_ref.clients.get_mut(&client_id).unwrap();
                                    if client.lobby_id.is_some() {
                                        // Find the lobby the client is in
                                        let lobby_id = client.lobby_id.as_ref().unwrap().clone();
                                        let mut found_lobby = state_ref.lobbies.get_mut(&lobby_id).unwrap();

                                        // Find the position in which the player is in the lobby and remove it
                                        let client_position = found_lobby.player_ids.iter().position(|id|
                                            id.eq(&client.id)
                                        ).unwrap();
                                        found_lobby.player_ids.remove(client_position);
                                        client.lobby_id = None;

                                        // If the lobby is empty, remove it from the server
                                        if found_lobby.player_ids.len() == 0 {
                                            state_ref.lobbies.remove(&lobby_id);
                                        } else {
                                            // If client is owner, transfer ownership to another client
                                            if found_lobby.owner.eq(&client_id) {
                                                found_lobby.owner = found_lobby.player_ids[0].clone();
                                            }

                                            // Otherwise send remaining clients an updated lobby state
                                            let response = build_lobby_info_response(StatusCode::Success, found_lobby.clone());

                                            // Send all clients an updated lobby state.
                                            for id in found_lobby.player_ids.iter() {
                                                state_ref.clients.get(id).unwrap().socket.send_message(response.clone());
                                            }
                                        }

                                        // Send the client a LeaveLobbyResponse, confirming that the server_bin has removed the client from the lobby
                                        client_socket.send_message(build_server_headers(StatusCode::Success, MessageType::LeaveLobbyResponse));
                                    } else {
                                        client_socket.send_message(build_server_headers(StatusCode::NotInLobby, MessageType::LeaveLobbyResponse));
                                    }
                                }
                                MessageType::StartGameRequest => {
                                    match parse_message_data::<StartGameRequest>(remainder) {
                                        Ok(req) => {
                                            // Check if client is in a lobby first.
                                            let client = state_ref.clients.get(&client_id).unwrap();
                                            if let Some(lobby_id) = &client.lobby_id {
                                                let lobby = state_ref.lobbies.get_mut(lobby_id).unwrap();
                                                let player_req_met =
                                                    lobby.player_ids.len() >= lobby.game_metadata.min_required_players &&
                                                        lobby.player_ids.len() <= lobby.game_metadata.max_players;

                                                // Start game if player requirement is met, requested lobby is the one the client is in, and if the client is the owner of the lobby
                                                if req.lobby_id.eq(lobby_id) && lobby.owner.eq(&client_id) && player_req_met {
                                                    let mut new_game = state_ref.supported_games.get(&lobby.game_metadata.get_game_type_id()).unwrap().init_new();

                                                    // Add client IDs to game session
                                                    for id in lobby.player_ids.iter() {
                                                        new_game.add_player(id.clone());
                                                    }

                                                    // Tie game session to lobby by using the lobby ID as a key for the game session hash map
                                                    state_ref.games_in_progress.insert(lobby_id.clone(), new_game);

                                                    // Get the game state for the newly created game session and send it to the clients that are in the lobby
                                                    for id in lobby.player_ids.iter() {
                                                        let game = state_ref.games_in_progress.get(lobby_id).unwrap();
                                                        let game_state = build_game_state_response(StatusCode::Success, game.get_game_state());
                                                        state_ref.clients.get(id).unwrap().socket.send_message(game_state);
                                                    }

                                                    // Set lobby as the game is in progress
                                                    lobby.game_started = true;
                                                } else {
                                                    client_socket.send_message(build_server_headers(StatusCode::GameStartCriteriaNotMet, MessageType::ProtocolError));
                                                }
                                            } else {
                                                // If not in lobby, send error
                                                client_socket.send_message(build_server_headers(StatusCode::NotInLobby, MessageType::ProtocolError));
                                            }
                                        }
                                        Err(e) => {
                                            client_socket.send_message(build_server_error_response(e));
                                        }
                                    }
                                }
                                MessageType::MoveRequest => {
                                    match parse_message_data::<Box<dyn GameMove>>(remainder) {
                                        Ok(req) => {
                                            // If client wasn't in a lobby, it's definitely not in a game session.
                                            // Also lobby ID is used for the game session hash map too.
                                            let client = state_ref.clients.get(&client_id).unwrap();
                                            if let Some(lobby_id) = &client.lobby_id {
                                                // Make sure there is a game session associated with a lobby
                                                if let Some(game) = state_ref.games_in_progress.get_mut(lobby_id) {

                                                    // Check some conditions to see if the game is over or not
                                                    let game_ended = game.end_condition_met().0;
                                                    let is_move_valid = game.is_valid_move(&req);
                                                    if is_move_valid && !game_ended {
                                                        game.apply_move(&req);

                                                        // After applying a move to the game state, send all participating clients the updated game state
                                                        let game_state = build_game_state_response(StatusCode::Success, game.get_game_state());
                                                        for id in state_ref.lobbies.get(lobby_id).unwrap().player_ids.iter() {
                                                            state_ref.clients.get(id).unwrap().socket.send_message(game_state.clone());
                                                        }
                                                    } else if game_ended {
                                                        // If client tries to make a move but game is over, send a GameOver game_protocol error.
                                                        client.socket.send_message(build_server_headers(StatusCode::GameOver, MessageType::ProtocolError));
                                                    } else if is_move_valid {
                                                        // If client's move is invalid, then return an error.
                                                        client.socket.send_message(build_server_headers(StatusCode::InvalidMove, MessageType::ProtocolError));
                                                    }
                                                } else {
                                                    client_socket.send_message(build_server_headers(StatusCode::GameSessionNotFound, MessageType::ProtocolError));
                                                }
                                            } else {
                                                client_socket.send_message(build_server_headers(StatusCode::NotInLobby, MessageType::ProtocolError));
                                            }
                                        }
                                        Err(e) => {
                                            client_socket.send_message(build_server_error_response(e));
                                        }
                                    }

                                }
                                MessageType::ReturnToLobbyRequest => {
                                    // After a game session has ended, return client to the lobby
                                    let client = state_ref.clients.get(&client_id).unwrap();
                                    if let Some(lobby_id) = &client.lobby_id {
                                        // Make sure there is a game associated with the lobby.
                                        if let Some(game) = state_ref.games_in_progress.get_mut(lobby_id) {
                                            // Remove client from the game session. If no one is left in it, remove session from server.
                                            game.remove_player(client.id.clone());
                                            if game.get_player_num() == 0 {
                                                state_ref.games_in_progress.remove(lobby_id);
                                                state_ref.lobbies.get_mut(lobby_id).unwrap().game_started = false;
                                            }

                                            // Send client the lobby info so they know leaving the game session and returning to the lobby was successful.
                                            let lobby = state_ref.lobbies.get(lobby_id).unwrap();
                                            client.socket.send_message(build_lobby_info_response(StatusCode::Success, lobby.clone()));
                                        } else {
                                            client_socket.send_message(build_server_headers(StatusCode::GameSessionNotFound, MessageType::ProtocolError));
                                        }
                                    } else {
                                        client_socket.send_message(build_server_headers(StatusCode::NotInLobby, MessageType::ProtocolError));
                                    }
                                }
                                MessageType::Unsupported => {
                                    // This and default case send an UnsupportedRequestType error.
                                    client_socket.send_message(build_server_headers(StatusCode::UnsupportedRequestType, MessageType::ProtocolError));
                                }
                                _ => {
                                    client_socket.send_message(build_server_headers(StatusCode::UnsupportedRequestType, MessageType::ProtocolError));
                                }
                            };

                            // Increment expected message ID
                            if !is_id_empty {
                                let client = state_ref.clients.get_mut(&client_id).unwrap();
                                if client.next_message_id == u32::MAX {
                                    client.next_message_id = 0;
                                } else {
                                    client.next_message_id += 1;
                                }
                            }
                        } else {
                            // Shut down socket if there are any issues.
                            println!("Shutting down...");
                            match client_socket.shutdown(Shutdown::Both) {
                                Ok(_) => {}
                                Err(e) => {
                                    println!("Socket with client shutdown error. {:?}", e);
                                }
                            };
                            break;
                        }
                    }
                    Err(e) => {
                        println!("Read from client socket error: {}", e);
                    }
                }

            }
            // When the listening loop exits, do clean up.
            // Remove client from any lobby it's in.
            // Remove client from client list on server_bin.
            if !client_id.is_empty() {
                let mut state_lock = state_clone.lock().unwrap();
                let state_ref = state_lock.deref_mut();
                let clients = &mut state_ref.clients;
                let lobbies = &mut state_ref.lobbies;

                // Get client being handled in this thread and check if it is in a lobby.
                let client = clients.get_mut(&client_id).unwrap();
                if client.lobby_id.is_some() {
                    let lobby_id = client.lobby_id.as_ref().unwrap().clone();
                    // Get the lobby the client is in, find where the client is in the lobby player_ids list and remove it.
                    let mut found_lobby = lobbies.get_mut(&lobby_id).unwrap();
                    let client_position = found_lobby.player_ids.iter().position(|id|
                        id.eq(&client_id)
                    ).unwrap();
                    found_lobby.player_ids.remove(client_position);
                    client.lobby_id = None; // Set client lobby_id to None just to be safe even though client is removed later.

                    // If client is owner, transfer ownership to another client
                    if found_lobby.owner.eq(&client_id) {
                        found_lobby.owner = found_lobby.player_ids[0].clone();
                    }

                    // If there is a game going on, send remaining clients back to the lobby and close the game session.
                    if state_ref.games_in_progress.contains_key(&lobby_id) {
                        for id in found_lobby.player_ids.iter() {
                            let message = build_lobby_info_response(StatusCode::Success, found_lobby.clone());
                            clients.get(id).unwrap().socket.send_message(message);
                        }
                    }

                    // If the lobby is empty, remove it from the server_bin
                    if found_lobby.player_ids.len() == 0 {
                        lobbies.remove(&lobby_id);
                    }
                }
                clients.remove(&client_id);
            }
        });
    }
}