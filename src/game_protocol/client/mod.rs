use std::io::{Read, Write};
use std::net::{Shutdown, TcpStream};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use crate::client::client_message_utils::{build_client_headers, build_connect_request, build_create_lobby_request, build_join_lobby_request, build_move_request, build_start_game_request, parse_server_message_header};
use crate::common_message_utils::parse_message_data;
use crate::enums::{MessageType, ProtocolState, StatusCode};
use crate::game_module::{GameModule, GameMove, GameState};
use crate::shared_data::{ConnectResponse, Lobby, LobbyInfoResponse, LobbyListResponse, MissingMessageResponse, SupportedGamesResponse, UnsolicitedMessage};

mod client_message_utils;

/*
    Represents the client portion of the game protocol.
    Handles client operations and communications with server.
 */

// Represents the state of the game protocol client. Separate various fields that will be accessed across threads.
struct GameProtocolClientState {
    protocol_state: ProtocolState, // Current state protocol client is in
    previous_protocol_state: ProtocolState, // Previous state server was in
    next_message_num: u32, // Next message ID client will send
    client_id: String, // UUID for client which is generated by server
    unsolicited_message: String, // Store the most recent unsolicited message from the server.
    socket: Option<Arc<TcpStream>>, // Store the TCP socket on which the client is communicating if a connection with a server is established
    current_lobby: Option<Lobby>, // Store lobby info if the client is in a lobby
    lobbies: Vec<Lobby>, // Store list of lobbies obtained from server
    is_listening_async: bool, // Know whether or not client is listening for server responses on a separate thread
    game_in_progress: Option<Box<dyn GameModule>>, // If client is in the middle of a game, store the game module
    previous_message_cache: HashMap<u32, Vec<u8>>, // Cache previous message byte data indexed by message ID
    supported_games: HashMap<String, Arc<dyn GameModule>>, // Hash map of supported game module instances, indexed by game module ID
    matching_supported_games: Vec<(String, String)>, // List of games that both client and server support. Tuples are (game title, game module ID)
    on_message_received: Option<Box<dyn Fn() + Send + Sync>>, // Callback function to use when a message is received from the server
}

pub struct GameProtocolClient {
    ip: Option<String>, // IP address client is connected to
    port: Option<String>, // Port client is connected to on the IP address
    state: Arc<Mutex<GameProtocolClientState>>, // Thread safe pointer to a mutex of the game protocol client state. Needs to be thread safe of course, and use a mutex to avoid data races.
}

// Implementing the various functions game protocol clients should have
impl GameProtocolClient {
    pub fn new() -> Self {
        let state = Arc::new(Mutex::new(GameProtocolClientState {
            protocol_state: ProtocolState::Closed,
            previous_protocol_state: ProtocolState::Closed,
            current_lobby: None,
            socket: None,
            client_id: "".to_string(),
            lobbies: vec![],
            is_listening_async: false,
            game_in_progress: None,
            previous_message_cache: HashMap::new(),
            supported_games: HashMap::new(),
            matching_supported_games: vec![],
            next_message_num: 0,
            on_message_received: None,
            unsolicited_message: "".to_string()
        }));
        Self {
            state,
            ip: None,
            port: None,
        }
    }

    // Returns socket address client is connected to
    pub fn get_socket_address(&self) -> String {
        if let (Some(ip), Some(port)) = (&self.ip, &self.port) {
            return format!("{}:{}", ip, port);
        }
        "".to_string()
    }

    // Get which protocol state the client is in
    pub fn get_protocol_state(&self) -> ProtocolState {
        self.state.lock().unwrap().protocol_state
    }

    // Get clone of supported games. Can't return a reference since data is behind a mutex.
    pub fn get_supported_games(&self) -> Vec<(String, String)> {
        self.state.lock().unwrap().matching_supported_games.clone()
    }

    // Get clone of lobbies the server has. Can't return a reference since data is behind a mutex.
    pub fn get_lobby_list(&self) -> Vec<Lobby> {
        self.state.lock().unwrap().lobbies.clone()
    }

    // Get clone of current lobby the client is in. Can't return a reference since data is behind a mutex.
    pub fn get_current_lobby(&self) -> Option<Lobby> {
        self.state.lock().unwrap().current_lobby.clone()
    }

    // Get clone of client's ID. Can't return a reference since data is behind a mutex.
    pub fn get_client_id(&self) -> String {
        self.state.lock().unwrap().client_id.clone()
    }

    // Get clone of game state of in-progress game. Can't return a reference since data is behind a mutex.
    pub fn get_game_state(&self) -> Option<Box<dyn GameState>> {
        let state_lock = self.state.lock().unwrap();
        if let Some(game) = &state_lock.game_in_progress {
            Some(game.get_game_state().clone())
        } else {
            None
        }
    }

    // Get end condition data of the game.
    pub fn get_game_end_result(&self) -> Option<(bool, Option<String>)> {
        let state_lock = self.state.lock().unwrap();
        if let Some(game) = &state_lock.game_in_progress {
            Some(game.end_condition_met())
        } else {
            None
        }
    }

    // Set a callback function to run when client receives a server message.
    // Callback function has no arguments, must be thread safe, and a static lifetime
    pub fn on_message_received_callback(&self, callback: impl Fn() + Send + Sync + 'static) {
        let callback = Box::new(callback);
        self.state.lock().unwrap().on_message_received = Some(callback);
    }

    // Register a game module by using generics. Generic must have a static lifetime and implement the GameModule trait.
    // That way we know that the game module will be compatible with protocol operations.
    pub fn register_game<T: 'static + GameModule>(&mut self) {
        let game = Arc::new(T::new()); // Create a new instance of the module to use as a factory.

        // Add factory object to supported games hash map, indexed by the game module ID
        self.state.lock().unwrap().supported_games.insert(game.get_metadata().get_game_type_id(), game);
    }

    // Send message  to server to request lobby list.
    pub fn request_lobby_list(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::GettingLobbies;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::LobbyListRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send message to server to request list of server's supported games
    pub fn request_supported_games(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::GettingSupportedGames;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::SupportedGamesRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send message to server to request updated information for a lobby the client is a member of
    pub fn refresh_current_lobby(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::GettingLobbyInfo;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::LobbyInfoRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send message to server to request the server create a new lobby that hosts a particular game and move the client into the lobby.
    pub fn create_lobby(&mut self, game_type_id: &str) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::CreatingLobby;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_create_lobby_request(next_message_num, game_type_id.to_string()));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send message to server to request the server add the client to the requested lobby.
    pub fn join_lobby(&mut self, lobby_id: &str) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::JoiningLobby;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_join_lobby_request(next_message_num, lobby_id.to_string()));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to server to have server remove client from the lobby they are in.
    pub fn leave_lobby(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::LeavingLobby;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::LeaveLobbyRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to start the game that a lobby hosts. Only send if client is inside a lobby.
    pub fn start_game(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::CreatingGameSession;

        // Check if client is in a lobby first.
        let mut lobby_id = "".to_string();
        if let Some(lobby) = &state_lock.current_lobby {
            lobby_id = lobby.id.clone();
        }
        drop(state_lock);

        if lobby_id.is_empty() {
            return;
        }

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_start_game_request(next_message_num, lobby_id));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to make a move in the game state on the server.
    pub fn make_move(&mut self, game_move: &dyn GameMove) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_move_request(next_message_num, game_move));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to return to the lobby from a game session
    pub fn return_to_lobby(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::ReturnToLobbyRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to terminate the session between client and server
    pub fn disconnect(&mut self) {
        // Lock state object to get required message data and change protocol state.
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();
        let socket = state_lock.socket.as_ref().unwrap().clone();
        let next_message_num = state_lock.next_message_num;
        state_lock.protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::ClosingConnection;
        drop(state_lock);

        // Send message. Synchronously listen if the client isn't asynchronously listening for server messages.
        self.send_message(build_client_headers(next_message_num, MessageType::DisconnectRequest));
        if !self.state.lock().unwrap().is_listening_async {
            listen(socket, self.state.clone());
        }
    }

    // Send request to establish a session between a server and client
    pub fn connect(&mut self, ip: &String, port: &String) {
        // Return if socket is Some (has a value, already connected).
        if self.state.lock().unwrap().socket.is_some() {
            return;
        }

        // Set the game_protocol state and save the ip and port
        let mut state_lock = self.state.lock().unwrap();
        state_lock.previous_protocol_state = state_lock.protocol_state;
        state_lock.protocol_state = ProtocolState::Authenticating;
        self.ip = Some(ip.clone());
        self.port = Some(port.clone());

        // If stored socket is None (unassigned, not connected), then try to connect.
        match TcpStream::connect(self.get_socket_address()) {
            Ok(tcp_stream) => {
                // Store the socket and send a connect request.
                let socket = Arc::new(tcp_stream);
                state_lock.socket = Some(socket.clone());

                // Build connect request and send it
                let connect_request = build_connect_request(state_lock.next_message_num, None);
                drop(state_lock);

                self.send_message(connect_request);
                listen(socket, self.state.clone());
            }
            Err(e) => {
                state_lock.protocol_state = state_lock.protocol_state;
                state_lock.protocol_state = ProtocolState::Closed;
                println!("Connect error: {}", e);
            }
        }
    }

    // Private function for client to send a message to server.
    fn send_message(&mut self, data: Vec<u8>) {
        let state_clone = self.state.clone();
        let mut state_lock = state_clone.lock().unwrap();

        // Only send if the socket has bbeen set
        if state_lock.socket.is_some() {

            // Cache this message in case we need to resend it.
            let id  = state_lock.next_message_num;
            state_lock.previous_message_cache.insert(id, data.clone());

            // Handle incrementing message ID
            if state_lock.next_message_num == u32::MAX {
                state_lock.next_message_num = 0;
            } else {
                state_lock.next_message_num += 1;
            }
            match state_lock.socket.as_ref().unwrap().as_ref().write(data.as_slice()) {
                Ok(_) => {}
                Err(e) => {
                    println!("Socket write error. {:?}", e);
                }
            };
        }
    }

    // Listen for server responses asynchronously via a thread and looping through incoming messages.
    pub fn async_listen(&self) {
        let state_clone = self.state.clone();
        let socket_clone = self.state.lock().unwrap().socket.as_ref().unwrap().clone();
        thread::spawn(move || {
            state_clone.as_ref().lock().unwrap().is_listening_async = true;
            loop {
                if state_clone.as_ref().lock().unwrap().is_listening_async {
                    listen(socket_clone.clone(), state_clone.clone());
                } else {
                    break;
                }
            }
        });
    }

    // Stop listening async. Set the boolean so in async_listen it knows to break out of the loop.
    pub fn stop_async_listen(&self) {
        self.state.lock().unwrap().is_listening_async = false;
    }
}

// Listen for server messages. Decoupled from client object since accessing "self" in a thread causes some issues, so it's just easier to make a separate function.
fn listen(socket: Arc<TcpStream>, state: Arc<Mutex<GameProtocolClientState>>) {
    if state.lock().unwrap().socket.is_some() {
        let mut buffer = [0; 4096];
        match socket.as_ref().read(&mut buffer) {
            Ok(size) => {
                // If size is more than 0, then this is a legit message we are receiving.
                // If size is 0, then socket is closed, so formally shut it down.
                if size > 0 {
                    let (status_code, message_type, remainder) = parse_server_message_header(&buffer);
                    println!("From server: {:?}, {:?}, {}, {}", status_code, message_type, remainder.len(), size);

                    // Lock state mutex and match the message type to handle the message appropriately
                    let mut state_lock = state.lock().unwrap();
                    match message_type {
                        MessageType::ConnectResponse => {
                            // Only accept the ConnectResponse if it was successful and this client_bin was in the correct state: Authenticating.
                            if matches!(status_code, StatusCode::Success) {
                                match parse_message_data::<ConnectResponse>(remainder) {
                                    Ok(res) => {
                                        state_lock.client_id = res.client_id;
                                        state_lock.protocol_state = ProtocolState::Idle;
                                    },
                                    Err(e) => {
                                        println!("Message parse error. {:?}", e);
                                    }
                                }

                            }
                        }
                        MessageType::DisconnectResponse => {
                            // If successfully disconnected, reset the state to an initialized value
                            if matches!(status_code, StatusCode::Success) {
                                state_lock.protocol_state = ProtocolState::Closed;
                                state_lock.socket = None;
                                state_lock.current_lobby = None;
                                state_lock.client_id = "".to_string();
                                state_lock.lobbies = vec![];
                                state_lock.matching_supported_games = vec![];
                                state_lock.next_message_num = 0;
                            }
                        }
                        MessageType::LobbyListResponse => {
                            // Simply set list of lobbies retrieved from server to the state so it's accessible from the client.
                            if matches!(status_code, StatusCode::Success) {
                                match parse_message_data::<LobbyListResponse>(remainder) {
                                    Ok(res) => {
                                        state_lock.protocol_state = ProtocolState::Idle;
                                        state_lock.lobbies = res.lobbies;
                                    }
                                    Err(e) => {
                                        println!("Message parse error. {:?}", e);
                                    }
                                }
                            }
                        }
                        MessageType::SupportedGamesResponse => {
                            if matches!(status_code, StatusCode::Success) {
                                match parse_message_data::<SupportedGamesResponse>(remainder) {
                                    Ok(res) => {
                                        // Compare list of server_bin supported games with client_bin supported games.
                                        // Collect the matching games and store them since these are the ones the client_bin should only be able to create lobbies for and join.
                                        let mut matching_games = vec![];
                                        let supported_games = &state_lock.supported_games;
                                        for server_game_id in res.games.iter() {
                                            if supported_games.contains_key(server_game_id) {
                                                matching_games.push((
                                                    supported_games.get(server_game_id).unwrap().get_metadata().game_title.clone(),
                                                    server_game_id.clone()
                                                ));
                                            }
                                        }
                                        state_lock.protocol_state = ProtocolState::Idle;
                                        state_lock.matching_supported_games = matching_games;
                                    }
                                    Err(e) => {
                                        println!("Message parse error. {:?}", e);
                                    }
                                }
                            }
                        }
                        MessageType::LobbyInfoResponse => {
                            // Simple, set current lobby upon receiving lobby info
                            if matches!(status_code, StatusCode::Success) {
                                match parse_message_data::<LobbyInfoResponse>(remainder) {
                                    Ok(res) => {
                                        state_lock.protocol_state = ProtocolState::InLobby;
                                        state_lock.current_lobby = Some(res.lobby);
                                    }
                                    Err(e) => {
                                        println!("Message parse error. {:?}", e);
                                    }
                                }
                            }
                        }
                        MessageType::LeaveLobbyResponse => {
                            // Set client's current lobby to None now that it has left the lobby
                            if matches!(status_code, StatusCode::Success) {
                                state_lock.protocol_state = ProtocolState::Idle;
                                state_lock.current_lobby = None;
                            }
                        }
                        MessageType::GameStateResponse => {
                            // Handle receiving game state response. This will move the client into a game session or update it's existing game state.
                            match parse_message_data::<Box<dyn GameState>>(remainder) {
                                Ok(res) => {
                                    if matches!(state_lock.protocol_state, ProtocolState::CreatingGameSession) || matches!(state_lock.protocol_state, ProtocolState::InLobby) {
                                        let game_type_id = state_lock.current_lobby.as_ref().unwrap().game_metadata.get_game_type_id();
                                        let mut new_game = state_lock.supported_games.get(&game_type_id).unwrap().init_new();
                                        new_game.set_game_state(res);
                                        state_lock.game_in_progress = Some(new_game);
                                        state_lock.protocol_state = ProtocolState::GameRunning;
                                    } else if state_lock.game_in_progress.is_some() {
                                        // Update the game state for the game that is ongoing.
                                        state_lock.game_in_progress.as_mut().unwrap().set_game_state(res);
                                    }
                                }
                                Err(e) => {
                                    println!("Message parse error. {:?}", e);
                                }
                            }
                        }
                        MessageType::UnsolicitedMessage => {
                            // Set client state's message to the message received from the server
                            match parse_message_data::<UnsolicitedMessage>(remainder) {
                                Ok(res) => {
                                    state_lock.unsolicited_message = res.message;
                                }
                                Err(e) => {
                                    println!("Message parse error. {:?}", e);
                                }
                            }
                        }
                        MessageType::MissingMessageResponse => {
                            // Check which messages are missing and resend them to the server
                            match parse_message_data::<MissingMessageResponse>(remainder) {
                                Ok(res) => {
                                    // Copy the message cache so we don't need to use the state mutex to directly access the state
                                    let previous_message_cache = state_lock.previous_message_cache.clone();

                                    // Go through all missing IDs
                                    for id in res.missing_message_ids.iter() {
                                        // If the ID is in the message cache, attempt to resend it
                                        if let Some(message) = previous_message_cache.get(id) {
                                            match socket.as_ref().write(message.as_slice()) {
                                                Ok(_) => {}
                                                Err(e) => {
                                                    println!("Resending previous message error. {:?}", e);
                                                }
                                            }
                                        } else {
                                            // If the ID is not found, then sending other cached messages
                                            // will cause the server to keep sending MissingMessageResponses since the expected
                                            // message would not have been sent, and will never be sent.
                                            break;
                                        }
                                    }
                                }
                                Err(e) => {
                                    println!("Message parse error. {:?}", e);
                                }
                            }
                        }
                        MessageType::ProtocolError => {
                            // Revert protocol state to previous state if an error was encountered
                            state_lock.protocol_state = state_lock.previous_protocol_state;
                        }
                        MessageType::Unsupported => {}
                        _ => {} // Default and Unsupported. Do nothing if we get a message unsupported on the client_bin side.
                    };

                    // Run on message received callback if it was set
                    // Must re-lock state since it's possible for the mutex to be dropped during MissingMessageResponse handling
                    if let Some(callback) = &state_lock.on_message_received {
                        callback();
                    }
                } else {
                    // If read size is 0 then server terminated connect, so clean things up on the client side.
                    match socket.shutdown(Shutdown::Both) {
                        Ok(_) => {}
                        Err(e) => {
                            println!("Socket with server shutdown error. {:?}", e);
                        }
                    }
                }
            }
            Err(e) => {
                println!("Listen error: {}", e);
            }
        };
    }
}
